<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Demo</title>
    <style>
        .people_counter {
          text-align:center;
        }
    </style>
  </head>
  <body>
    <div style="width:100%; text-align:center;">
      <canvas id="draw" height="500" width="1000" style="border: 1px solid #111111; margin: auto"/>
    </div>
    <img class="twod"/>
    <div class = "people_counter"></div>
    <div class = "error-ctx"></div>
    <div id="countdown"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.1/tinycolor.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var host = "cpsc484-02.yale.internal:8888";
      
      $(document).ready(function() {
        PLAYING = false; 
          frames.start();
          twod.start();
      });

      var frames = {
        socket: null,

        start: function() {
          var url = "ws://" + host + "/frames";

          // canvas object
          var c = document.getElementById("draw");
          var ctx = c.getContext("2d");
          // all real-world units are in mm unless denoted by CM
          var personRadiusCM = 30;
          // origin (x,y)
          var origin = [c.width/2, 0];

          // subscribe to the /frames data
          frames.socket = new WebSocket(url);
          frames.socket.onmessage = function(event) {
            let data = JSON.parse(event.data);
            // clear the canvas
            ctx.clearRect(0, 0, c.width, c.height);
            // Insert code so that by default, the screen shows a message 
            
            // draw the camera on the top of the screen
            drawIntro(ctx, origin);
            // draw each person as a circle

            var i = 0;
            if (data.people) {
              ctx.clearRect(0, 0, c.width, c.height);
              var num_people = Object.keys(data.people).length;
              $('.people_counter').text(`I see ${num_people} people`);
              console.log(num_people);
              if (num_people > 1){
                // IN this case, we inform the users that only one player is allowed
                $('.error-ctx').show();
                $('.error-ctx').text(`Error: Please Only one person per screen`);
                console.log("Error");
               setTimeout(function(){
                $('.error-ctx').hide();
                        }, 5000); 
              } 
              [idx, person] =  Object.entries(data.peope)[0]; 
              if(person.joints[8].position.y < person.joints[3]){
                // If arm is raised 
                  PLAYING = true; 
              }
              if(PLAYING == true){
              for (const [idx, person] of Object.entries(data.people)) {
                // we want the data on the x,z plane from the camera's frame, so use indicies and 0 (x), 2 (Z)
                // see: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes#arcs
                // function definition is: arc(x, y, radius, startAngle, endAngle, counterclockwise)
                ctx.strokeStyle = ctx.fillStyle = colors[i++];
                ctx.beginPath();
                // Code to detect where the person is, relative to the middle of the display 
                const POSITIONS = {
                  LEFT : "left",
                  RIGHT: "right"
                }
                if(person.x_pos < 0){
                  // Here, the person is standing on the left 
                  POSITION = "left" ;
                  ctx.fillStyle = 'grey';
                  ctx.fillRect(0, 0, ctx.canvas.clientWidth/2, ctx.canvas.clientHeight);
                  ctx.fillStyle = '#333333';
                  ctx.fillRect(ctx.canvas.clientWidth*2/5, 0, ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/6);

                  ctx.font = "25px Calibri";
                  ctx.fillText("Option 1", ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/2);
                  ctx.fillText("Option 2", ctx.canvas.clientWidth*7/10, ctx.canvas.clientHeight/2);
                  ctx.fillStyle = "#FFFFFF";
                  ctx.fillText("Upvote!", ctx.canvas.clientWidth*9.2/20, ctx.canvas.clientHeight/10);
                } else{
                  POSITION = "right"; 
                  ctx.fillStyle = 'grey';
                  ctx.fillRect(ctx.canvas.clientWidth/2, 0, ctx.canvas.clientWidth/2, ctx.canvas.clientHeight);
                  ctx.fillStyle = '#333333';
                  ctx.fillRect(ctx.canvas.clientWidth*2/5, 0, ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/6);

                  ctx.font = "25px Calibri";
                  ctx.fillText("Option 1", ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/2);
                  ctx.fillText("Option 2", ctx.canvas.clientWidth*7/10, ctx.canvas.clientHeight/2);
                  ctx.fillStyle = "#FFFFFF";
                  ctx.fillText("Upvote!", ctx.canvas.clientWidth*9.2/20, ctx.canvas.clientHeight/10);
                }
                $('.people_counter').text(`The person is at the ${POSITION} of the screen`);

                let person_x = -1 * toCM(person.avg_position[0]) + origin[0]
                let person_y = toCM(person.avg_position[2]) + origin[1]
                ctx.arc(person_x, person_y, personRadiusCM, 0, 2 * Math.PI);
                ctx.stroke();
                if (person.theta) {
                  ctx.beginPath();
                  let th = person.theta;
                  let arrow_x = person_x + Math.cos(th) * personRadiusCM;
                  let arrow_y = person_y - Math.sin(th) * personRadiusCM;
                  ctx.stroke();
                }
              }
            }
            }
          }
        }
      };

      var twod = {
        socket: null,

        // create a connection to the camera feed
        start: function () {
            var url = "ws://" + host + "/twod";
            twod.socket = new WebSocket(url);

            // whenever a new frame is received...
            twod.socket.onmessage = function (event) {

                // parse and show the raw data
                twod.show(JSON.parse(event.data));
            }
        },

        // show the image by adjusting the source attribute of the HTML img object previously created
        show: function (twod) {
            $('img.twod').attr("src", 'data:image/pnjpegg;base64,' + twod.src);
        },
      };


      // Helper Functions

      // Convert MM to CM
      function toCM(mm) {
        return mm/10;
      }

      // Setup an array of colors
      var tc = tinycolor({
        r: Math.floor(Math.random() * 0xFF),
        g: Math.floor(Math.random() * 0xFF),
        b: Math.floor(Math.random() * 0xFF)
      });
      colors = [];
      var parts = 2 + Math.floor(Math.random() * 5);
      for (var i = 0; i < parts; i++) {
        tc = tc.spin(360 / parts);
        colors.push('#' + tc.toHex());
      }
      function drawIntro(ctx, origin){
        ctx.strokeStyle = "blue"; 
        ctx.fillStyle = 'white';
        ctx.font = "25px Calibri";
        ctx.fillRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight); 
        ctx.fillStyle = 'red';
        ctx.fillText("Hey, wanna play a cool game? Raise your hand and start", ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/2);
        
      }
      // Draw the environment
      function drawEnv(ctx, origin) {
        ctx.strokeStyle = "#333333";
        // ctx.fillStyle = '#FFFFFF';
        // ctx.fillRect(0, 0, ctx.canvas.clientWidth/2, ctx.canvas.clientHeight);
        // ctx.fillStyle = '#FFFFFF';
        // ctx.fillRect(ctx.canvas.clientWidth/2, 0, ctx.canvas.clientWidth/2, ctx.canvas.clientHeight)
        ctx.fillStyle = '#333333';
        ctx.fillRect(ctx.canvas.clientWidth*2/5, 0, ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/6);

        ctx.font = "25px Calibri";
        ctx.fillText("Option 1", ctx.canvas.clientWidth/5, ctx.canvas.clientHeight/2);
        ctx.fillText("Option 2", ctx.canvas.clientWidth*7/10, ctx.canvas.clientHeight/2);
        ctx.fillStyle = "#FFFFFF";
        ctx.fillText("Upvote!", ctx.canvas.clientWidth*9.2/20, ctx.canvas.clientHeight/10);

        ctx.beginPath();
        ctx.moveTo(ctx.canvas.clientWidth/2, ctx.canvas.clientHeight/10);
        ctx.lineTo(ctx.canvas.clientWidth/2, ctx.canvas.clientHeight);
        ctx.stroke();

      }

    </script>
  </body>
</html>
